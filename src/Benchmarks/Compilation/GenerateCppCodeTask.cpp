/*
 *  Copyright (c) 2025  Ioannis Panagiotopoulos
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

//
// Created by klapeto on 20/12/2024.
//

#include "GenerateCppCodeTask.hpp"
#include <cstring>

namespace Elpida
{
	const char Source[] = "/*\n"
						  " * musl as a whole is licensed under the following standard MIT license:\n"
						  "\n"
						  "----------------------------------------------------------------------\n"
						  "Copyright © 2005-2020 Rich Felker, et al.\n"
						  "\n"
						  "Permission is hereby granted, free of charge, to any person obtaining\n"
						  "a copy of this software and associated documentation files (the\n"
						  "\"Software\"), to deal in the Software without restriction, including\n"
						  "without limitation the rights to use, copy, modify, merge, publish,\n"
						  "distribute, sublicense, and/or sell copies of the Software, and to\n"
						  "permit persons to whom the Software is furnished to do so, subject to\n"
						  "the following conditions:\n"
						  "\n"
						  "The above copyright notice and this permission notice shall be\n"
						  "included in all copies or substantial portions of the Software.\n"
						  "\n"
						  "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n"
						  "EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n"
						  "MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n"
						  "IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n"
						  "CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n"
						  "TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n"
						  "SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
						  "----------------------------------------------------------------------\n"
						  "\n"
						  "Authors/contributors include:\n"
						  "\n"
						  "A. Wilcox\n"
						  "Ada Worcester\n"
						  "Alex Dowad\n"
						  "Alex Suykov\n"
						  "Alexander Monakov\n"
						  "Andre McCurdy\n"
						  "Andrew Kelley\n"
						  "Anthony G. Basile\n"
						  "Aric Belsito\n"
						  "Arvid Picciani\n"
						  "Bartosz Brachaczek\n"
						  "Benjamin Peterson\n"
						  "Bobby Bingham\n"
						  "Boris Brezillon\n"
						  "Brent Cook\n"
						  "Chris Spiegel\n"
						  "Clément Vasseur\n"
						  "Daniel Micay\n"
						  "Daniel Sabogal\n"
						  "Daurnimator\n"
						  "David Carlier\n"
						  "David Edelsohn\n"
						  "Denys Vlasenko\n"
						  "Dmitry Ivanov\n"
						  "Dmitry V. Levin\n"
						  "Drew DeVault\n"
						  "Emil Renner Berthing\n"
						  "Fangrui Song\n"
						  "Felix Fietkau\n"
						  "Felix Janda\n"
						  "Gianluca Anzolin\n"
						  "Hauke Mehrtens\n"
						  "He X\n"
						  "Hiltjo Posthuma\n"
						  "Isaac Dunham\n"
						  "Jaydeep Patil\n"
						  "Jens Gustedt\n"
						  "Jeremy Huntwork\n"
						  "Jo-Philipp Wich\n"
						  "Joakim Sindholt\n"
						  "John Spencer\n"
						  "Julien Ramseier\n"
						  "Justin Cormack\n"
						  "Kaarle Ritvanen\n"
						  "Khem Raj\n"
						  "Kylie McClain\n"
						  "Leah Neukirchen\n"
						  "Luca Barbato\n"
						  "Luka Perkov\n"
						  "M Farkas-Dyck (Strake)\n"
						  "Mahesh Bodapati\n"
						  "Markus Wichmann\n"
						  "Masanori Ogino\n"
						  "Michael Clark\n"
						  "Michael Forney\n"
						  "Mikhail Kremnyov\n"
						  "Natanael Copa\n"
						  "Nicholas J. Kain\n"
						  "orc\n"
						  "Pascal Cuoq\n"
						  "Patrick Oppenlander\n"
						  "Petr Hosek\n"
						  "Petr Skocik\n"
						  "Pierre Carrier\n"
						  "Reini Urban\n"
						  "Rich Felker\n"
						  "Richard Pennington\n"
						  "Ryan Fairfax\n"
						  "Samuel Holland\n"
						  "Segev Finer\n"
						  "Shiz\n"
						  "sin\n"
						  "Solar Designer\n"
						  "Stefan Kristiansson\n"
						  "Stefan O'Rear\n"
						  "Szabolcs Nagy\n"
						  "Timo Teräs\n"
						  "Trutz Behn\n"
						  "Valentin Ochs\n"
						  "Will Dietz\n"
						  "William Haddon\n"
						  "William Pitcock\n"
						  "\n"
						  "Portions of this software are derived from third-party works licensed\n"
						  "under terms compatible with the above MIT license:\n"
						  "\n"
						  "The TRE regular expression implementation (src/regex/reg* and\n"
						  "src/regex/tre*) is Copyright © 2001-2008 Ville Laurikari and licensed\n"
						  "under a 2-clause BSD license (license text in the source files). The\n"
						  "included version has been heavily modified by Rich Felker in 2012, in\n"
						  "the interests of size, simplicity, and namespace cleanliness.\n"
						  "\n"
						  "Much of the math library code (src/math and src/complex) is\n"
						  "Copyright © 1993,2004 Sun Microsystems or\n"
						  "Copyright © 2003-2011 David Schultz or\n"
						  "Copyright © 2003-2009 Steven G. Kargl or\n"
						  "Copyright © 2003-2009 Bruce D. Evans or\n"
						  "Copyright © 2008 Stephen L. Moshier or\n"
						  "Copyright © 2017-2018 Arm Limited\n"
						  "and labelled as such in comments in the individual source files. All\n"
						  "have been licensed under extremely permissive terms.\n"
						  "\n"
						  "The ARM memcpy code (src/string/arm/memcpy.S) is Copyright © 2008\n"
						  "The Android Open Source Project and is licensed under a two-clause BSD\n"
						  "license. It was taken from Bionic libc, used on Android.\n"
						  "\n"
						  "The AArch64 memcpy and memset code (src/string/aarch64) are\n"
						  "Copyright © 1999-2019, Arm Limited.\n"
						  "\n"
						  "The implementation of DES for crypt (src/crypt/crypt_des.c) is\n"
						  "Copyright © 1994 David Burren. It is licensed under a BSD license.\n"
						  "\n"
						  "The implementation of blowfish crypt (src/crypt/crypt_blowfish.c) was\n"
						  "originally written by Solar Designer and placed into the public\n"
						  "domain. The code also comes with a fallback permissive license for use\n"
						  "in jurisdictions that may not recognize the public domain.\n"
						  "\n"
						  "The smoothsort implementation (src/stdlib/qsort.c) is Copyright © 2011\n"
						  "Valentin Ochs and is licensed under an MIT-style license.\n"
						  "\n"
						  "The x86_64 port was written by Nicholas J. Kain and is licensed under\n"
						  "the standard MIT terms.\n"
						  "\n"
						  "The mips and microblaze ports were originally written by Richard\n"
						  "Pennington for use in the ellcc project. The original code was adapted\n"
						  "by Rich Felker for build system and code conventions during upstream\n"
						  "integration. It is licensed under the standard MIT terms.\n"
						  "\n"
						  "The mips64 port was contributed by Imagination Technologies and is\n"
						  "licensed under the standard MIT terms.\n"
						  "\n"
						  "The powerpc port was also originally written by Richard Pennington,\n"
						  "and later supplemented and integrated by John Spencer. It is licensed\n"
						  "under the standard MIT terms.\n"
						  "\n"
						  "All other files which have no copyright comments are original works\n"
						  "produced specifically for use as part of this library, written either\n"
						  "by Rich Felker, the main author of the library, or by one or more\n"
						  "contibutors listed above. Details on authorship of individual files\n"
						  "can be found in the git version control history of the project. The\n"
						  "omission of copyright and license comments in each file is in the\n"
						  "interest of source tree size.\n"
						  "\n"
						  "In addition, permission is hereby granted for all public header files\n"
						  "(include and arch/bits) and crt files intended to be linked into\n"
						  "applications (crt, ldso/dlstart.c, and arch/crt_arch.h) to omit\n"
						  "the copyright notice and permission notice otherwise required by the\n"
						  "\t\tlicense, and to use these files without any requirement of\n"
						  "\t\tattribution. These files include substantial contributions from:\n"
						  "\n"
						  "Bobby Bingham\n"
						  "John Spencer\n"
						  "Nicholas J. Kain\n"
						  "\t\tRich Felker\n"
						  "\t\tRichard Pennington\n"
						  "\t\tStefan Kristiansson\n"
						  "\t\tSzabolcs Nagy\n"
						  "\n"
						  "\t\tall of whom have explicitly granted such permission.\n"
						  "\n"
						  "This file previously contained text expressing a belief that most of\n"
						  "\t\tthe files covered by the above exception were sufficiently trivial not\n"
						  "to be subject to copyright, resulting in confusion over whether it\n"
						  "negated the permissions granted in the license. In the spirit of\n"
						  "permissive licensing, and of not having licensing issues being an\n"
						  "\t\tobstacle to adoption, that text has been removed.\n"
						  "*/\n"
						  "\n"
						  "//\n"
						  "// Created by klapeto on 22/12/2024.\n"
						  "//\n"
						  "\n"
						  "using Size = unsigned long long int;\n"
						  "using uint32_t = unsigned int;\n"
						  "using uint64_t = unsigned long long int;\n"
						  "using uint16_t = unsigned short;\n"
						  "\n"
						  "#define FP_NAN       0\n"
						  "#define FP_INFINITE  1\n"
						  "#define FP_ZERO      2\n"
						  "#define FP_SUBNORMAL 3\n"
						  "#define FP_NORMAL    4\n"
						  "\n"
						  "#define __BYTE_ORDER 1234\n"
						  "#define __LITTLE_ENDIAN 1234\n"
						  "#define __BIG_ENDIAN 4321\n"
						  "\n"
						  "union ldshape {\n"
						  "\tlong double f;\n"
						  "\tstruct {\n"
						  "\t\tuint64_t m;\n"
						  "\t\tuint16_t se;\n"
						  "\t} i;\n"
						  "};\n"
						  "\n"
						  "union AsDoubleS\n"
						  "{\n"
						  "\tuint64_t _i;\n"
						  "\tdouble _f;\n"
						  "};\n"
						  "union AsUint64S\n"
						  "{\n"
						  "\tdouble _f;\n"
						  "\tuint64_t _i;\n"
						  "};\n"
						  "#define asuint(f) ((union{float _f; uint32_t _i;}){f})._i\n"
						  "#define asfloat(i) ((union{uint32_t _i; float _f;}){i})._f\n"
						  "#define asuint64(f) (AsUint64S{f})._i\n"
						  "#define asdouble(i) (AsDoubleS{i})._f\n"
						  "\n"
						  "#define predict_true(x) (x)\n"
						  "#define predict_false(x) (x)\n"
						  "\n"
						  "#define FENV_SUPPORT 1\n"
						  "\n"
						  "void *memcpy(void *  dest, const void * src, Size n)\n"
						  "{\n"
						  "\tunsigned char *d = (unsigned char*)dest;\n"
						  "\tconst unsigned char *s = (unsigned char*)src;\n"
						  "\n"
						  "\tfor (; n; n--) *d++ = *s++;\n"
						  "\treturn dest;\n"
						  "}\n"
						  "\n"
						  "static const uint16_t __rsqrt_tab[128] = {\n"
						  "\t\t0xb451, 0xb2f0, 0xb196, 0xb044, 0xaef9, 0xadb6, 0xac79, 0xab43,\n"
						  "\t\t0xaa14, 0xa8eb, 0xa7c8, 0xa6aa, 0xa592, 0xa480, 0xa373, 0xa26b,\n"
						  "\t\t0xa168, 0xa06a, 0x9f70, 0x9e7b, 0x9d8a, 0x9c9d, 0x9bb5, 0x9ad1,\n"
						  "\t\t0x99f0, 0x9913, 0x983a, 0x9765, 0x9693, 0x95c4, 0x94f8, 0x9430,\n"
						  "\t\t0x936b, 0x92a9, 0x91ea, 0x912e, 0x9075, 0x8fbe, 0x8f0a, 0x8e59,\n"
						  "\t\t0x8daa, 0x8cfe, 0x8c54, 0x8bac, 0x8b07, 0x8a64, 0x89c4, 0x8925,\n"
						  "\t\t0x8889, 0x87ee, 0x8756, 0x86c0, 0x862b, 0x8599, 0x8508, 0x8479,\n"
						  "\t\t0x83ec, 0x8361, 0x82d8, 0x8250, 0x81c9, 0x8145, 0x80c2, 0x8040,\n"
						  "\t\t0xff02, 0xfd0e, 0xfb25, 0xf947, 0xf773, 0xf5aa, 0xf3ea, 0xf234,\n"
						  "\t\t0xf087, 0xeee3, 0xed47, 0xebb3, 0xea27, 0xe8a3, 0xe727, 0xe5b2,\n"
						  "\t\t0xe443, 0xe2dc, 0xe17a, 0xe020, 0xdecb, 0xdd7d, 0xdc34, 0xdaf1,\n"
						  "\t\t0xd9b3, 0xd87b, 0xd748, 0xd61a, 0xd4f1, 0xd3cd, 0xd2ad, 0xd192,\n"
						  "\t\t0xd07b, 0xcf69, 0xce5b, 0xcd51, 0xcc4a, 0xcb48, 0xca4a, 0xc94f,\n"
						  "\t\t0xc858, 0xc764, 0xc674, 0xc587, 0xc49d, 0xc3b7, 0xc2d4, 0xc1f4,\n"
						  "\t\t0xc116, 0xc03c, 0xbf65, 0xbe90, 0xbdbe, 0xbcef, 0xbc23, 0xbb59,\n"
						  "\t\t0xba91, 0xb9cc, 0xb90a, 0xb84a, 0xb78c, 0xb6d0, 0xb617, 0xb560,\n"
						  "};\n"
						  "\n"
						  "static double __math_invalid(double x)\n"
						  "{\n"
						  "\treturn (x - x) / (x - x);\n"
						  "}\n"
						  "\n"
						  "/* returns a*b*2^-32 - e, with error 0 <= e < 1.  */\n"
						  "static inline uint32_t mul32(uint32_t a, uint32_t b)\n"
						  "{\n"
						  "\treturn (uint64_t)a * b >> 32;\n"
						  "}\n"
						  "\n"
						  "/* returns a*b*2^-64 - e, with error 0 <= e < 3.  */\n"
						  "static inline uint64_t mul64(uint64_t a, uint64_t b)\n"
						  "{\n"
						  "\tuint64_t ahi = a >> 32;\n"
						  "\tuint64_t alo = a & 0xffffffff;\n"
						  "\tuint64_t bhi = b >> 32;\n"
						  "\tuint64_t blo = b & 0xffffffff;\n"
						  "\treturn ahi * bhi + (ahi * blo >> 32) + (alo * bhi >> 32);\n"
						  "}\n"
						  "\n"
						  "static inline double eval_as_double(double x)\n"
						  "{\n"
						  "\tdouble y = x;\n"
						  "\treturn y;\n"
						  "}\n"
						  "\n"
						  "double sqrt(double x)\n"
						  "{\n"
						  "\tuint64_t ix, top, m;\n"
						  "\n"
						  "\t/* special case handling.  */\n"
						  "\tix = asuint64(x);\n"
						  "\ttop = ix >> 52;\n"
						  "\tif (predict_false(top - 0x001 >= 0x7ff - 0x001))\n"
						  "\t{\n"
						  "\t\t/* x < 0x1p-1022 or inf or nan.  */\n"
						  "\t\tif (ix * 2 == 0)\n"
						  "\t\t\treturn x;\n"
						  "\t\tif (ix == 0x7ff0000000000000)\n"
						  "\t\t\treturn x;\n"
						  "\t\tif (ix > 0x7ff0000000000000)\n"
						  "\t\t\treturn __math_invalid(x);\n"
						  "\t\t/* x is subnormal, normalize it.  */\n"
						  "\t\tix = asuint64(x * 0x1p52);\n"
						  "\t\ttop = ix >> 52;\n"
						  "\t\ttop -= 52;\n"
						  "\t}\n"
						  "\n"
						  "\t/* argument reduction:\n"
						  "\t   x = 4^e m; with integer e, and m in [1, 4)\n"
						  "\t   m: fixed point representation [2.62]\n"
						  "\t   2^e is the exponent part of the result.  */\n"
						  "\tint even = top & 1;\n"
						  "\tm = (ix << 11) | 0x8000000000000000;\n"
						  "\tif (even) m >>= 1;\n"
						  "\ttop = (top + 0x3ff) >> 1;\n"
						  "\n"
						  "\t/* approximate r ~ 1/sqrt(m) and s ~ sqrt(m) when m in [1,4)\n"
						  "\n"
						  "\t   initial estimate:\n"
						  "\t   7bit table lookup (1bit exponent and 6bit significand).\n"
						  "\n"
						  "\t   iterative approximation:\n"
						  "\t   using 2 goldschmidt iterations with 32bit int arithmetics\n"
						  "\t   and a final iteration with 64bit int arithmetics.\n"
						  "\n"
						  "\t   details:\n"
						  "\n"
						  "\t   the relative error (e = r0 sqrt(m)-1) of a linear estimate\n"
						  "\t   (r0 = a m + b) is |e| < 0.085955 ~ 0x1.6p-4 at best,\n"
						  "\t   a table lookup is faster and needs one less iteration\n"
						  "\t   6 bit lookup table (128b) gives |e| < 0x1.f9p-8\n"
						  "\t   7 bit lookup table (256b) gives |e| < 0x1.fdp-9\n"
						  "\t   for single and double prec 6bit is enough but for quad\n"
						  "\t   prec 7bit is needed (or modified iterations). to avoid\n"
						  "\t   one more iteration >=13bit table would be needed (16k).\n"
						  "\n"
						  "\t   a newton-raphson iteration for r is\n"
						  "\t     w = r*r\n"
						  "\t     u = 3 - m*w\n"
						  "\t     r = r*u/2\n"
						  "\t   can use a goldschmidt iteration for s at the end or\n"
						  "\t     s = m*r\n"
						  "\n"
						  "\t   first goldschmidt iteration is\n"
						  "\t     s = m*r\n"
						  "\t     u = 3 - s*r\n"
						  "\t     r = r*u/2\n"
						  "\t     s = s*u/2\n"
						  "\t   next goldschmidt iteration is\n"
						  "\t     u = 3 - s*r\n"
						  "\t     r = r*u/2\n"
						  "\t     s = s*u/2\n"
						  "\t   and at the end r is not computed only s.\n"
						  "\n"
						  "\t   they use the same amount of operations and converge at the\n"
						  "\t   same quadratic rate, i.e. if\n"
						  "\t     r1 sqrt(m) - 1 = e, then\n"
						  "\t     r2 sqrt(m) - 1 = -3/2 e^2 - 1/2 e^3\n"
						  "\t   the advantage of goldschmidt is that the mul for s and r\n"
						  "\t   are independent (computed in parallel), however it is not\n"
						  "\t   \"self synchronizing\": it only uses the input m in the\n"
						  "\t   first iteration so rounding errors accumulate. at the end\n"
						  "\t   or when switching to larger precision arithmetics rounding\n"
						  "\t   errors dominate so the first iteration should be used.\n"
						  "\n"
						  "\t   the fixed point representations are\n"
						  "\t     m: 2.30 r: 0.32, s: 2.30, d: 2.30, u: 2.30, three: 2.30\n"
						  "\t   and after switching to 64 bit\n"
						  "\t     m: 2.62 r: 0.64, s: 2.62, d: 2.62, u: 2.62, three: 2.62  */\n"
						  "\n"
						  "\tstatic const uint64_t three = 0xc0000000;\n"
						  "\tuint64_t r, s, d, u, i;\n"
						  "\n"
						  "\ti = (ix >> 46) % 128;\n"
						  "\tr = (uint32_t)__rsqrt_tab[i] << 16;\n"
						  "\t/* |r sqrt(m) - 1| < 0x1.fdp-9 */\n"
						  "\ts = mul32(m >> 32, r);\n"
						  "\t/* |s/sqrt(m) - 1| < 0x1.fdp-9 */\n"
						  "\td = mul32(s, r);\n"
						  "\tu = three - d;\n"
						  "\tr = mul32(r, u) << 1;\n"
						  "\t/* |r sqrt(m) - 1| < 0x1.7bp-16 */\n"
						  "\ts = mul32(s, u) << 1;\n"
						  "\t/* |s/sqrt(m) - 1| < 0x1.7bp-16 */\n"
						  "\td = mul32(s, r);\n"
						  "\tu = three - d;\n"
						  "\tr = mul32(r, u) << 1;\n"
						  "\t/* |r sqrt(m) - 1| < 0x1.3704p-29 (measured worst-case) */\n"
						  "\tr = r << 32;\n"
						  "\ts = mul64(m, r);\n"
						  "\td = mul64(s, r);\n"
						  "\tu = (three << 32) - d;\n"
						  "\ts = mul64(s, u);  /* repr: 3.61 */\n"
						  "\t/* -0x1p-57 < s - sqrt(m) < 0x1.8001p-61 */\n"
						  "\ts = (s - 2) >> 9; /* repr: 12.52 */\n"
						  "\t/* -0x1.09p-52 < s - sqrt(m) < -0x1.fffcp-63 */\n"
						  "\n"
						  "\t/* s < sqrt(m) < s + 0x1.09p-52,\n"
						  "\t   compute nearest rounded result:\n"
						  "\t   the nearest result to 52 bits is either s or s+0x1p-52,\n"
						  "\t   we can decide by comparing (2^52 s + 0.5)^2 to 2^104 m.  */\n"
						  "\tuint64_t d0, d1, d2;\n"
						  "\tdouble y, t;\n"
						  "\td0 = (m << 42) - s * s;\n"
						  "\td1 = s - d0;\n"
						  "\td2 = d1 + s + 1;\n"
						  "\ts += d1 >> 63;\n"
						  "\ts &= 0x000fffffffffffff;\n"
						  "\ts |= top << 52;\n"
						  "\ty = asdouble(s);\n"
						  "\tif (FENV_SUPPORT)\n"
						  "\t{\n"
						  "\t\t/* handle rounding modes and inexact exception:\n"
						  "\t\t   only (s+1)^2 == 2^42 m case is exact otherwise\n"
						  "\t\t   add a tiny value to cause the fenv effects.  */\n"
						  "\t\tuint64_t tiny = predict_false(d2 == 0) ? 0 : 0x0010000000000000;\n"
						  "\t\ttiny |= (d1 ^ d2) & 0x8000000000000000;\n"
						  "\t\tt = asdouble(tiny);\n"
						  "\t\ty = eval_as_double(y + t);\n"
						  "\t}\n"
						  "\treturn y;\n"
						  "}\n"
						  "\n"
						  "double abs(double x)\n"
						  "{\n"
						  "\tunion {double f; uint64_t i;} u = {x};\n"
						  "\tu.i &= -1ULL/2;\n"
						  "\treturn u.f;\n"
						  "}\n"
						  "\n"
						  "static __inline unsigned __FLOAT_BITS(float __f)\n"
						  "{\n"
						  "\tunion {float __f; unsigned __i;} __u;\n"
						  "\t__u.__f = __f;\n"
						  "\treturn __u.__i;\n"
						  "}\n"
						  "\n"
						  "static __inline unsigned long long __DOUBLE_BITS(double __f)\n"
						  "{\n"
						  "\tunion {double __f; unsigned long long __i;} __u;\n"
						  "\t__u.__f = __f;\n"
						  "\treturn __u.__i;\n"
						  "}\n"
						  "\n"
						  "#define isnan(x) ( \\\n"
						  "\tsizeof(x) == sizeof(float) ? (__FLOAT_BITS(x) & 0x7fffffff) > 0x7f800000 : \\\n"
						  "\tsizeof(x) == sizeof(double) ? (__DOUBLE_BITS(x) & -1ULL>>1) > 0x7ffULL<<52 : \\\n"
						  "\t__fpclassifyl(x) == FP_NAN)\n"
						  "\n"
						  "int __fpclassifyl(long double x)\n"
						  "{\n"
						  "\tunion ldshape u = {x};\n"
						  "\tint e = u.i.se & 0x7fff;\n"
						  "\tint msb = u.i.m>>63;\n"
						  "\tif (!e && !msb)\n"
						  "\t\treturn u.i.m ? FP_SUBNORMAL : FP_ZERO;\n"
						  "\tif (e == 0x7fff) {\n"
						  "\t\t/* The x86 variant of 80-bit extended precision only admits\n"
						  "\t\t * one representation of each infinity, with the mantissa msb\n"
						  "\t\t * necessarily set. The version with it clear is invalid/nan.\n"
						  "\t\t * The m68k variant, however, allows either, and tooling uses\n"
						  "\t\t * the version with it clear. */\n"
						  "\t\tif (__BYTE_ORDER == __LITTLE_ENDIAN && !msb)\n"
						  "\t\t\treturn FP_NAN;\n"
						  "\t\treturn u.i.m << 1 ? FP_NAN : FP_INFINITE;\n"
						  "\t}\n"
						  "\tif (!msb)\n"
						  "\t\treturn FP_NAN;\n"
						  "\treturn FP_NORMAL;\n"
						  "}\n"
						  "\n"
						  "double fmod(double x, double y)\n"
						  "{\n"
						  "\tunion {double f; uint64_t i;} ux = {x}, uy = {y};\n"
						  "\tint ex = ux.i>>52 & 0x7ff;\n"
						  "\tint ey = uy.i>>52 & 0x7ff;\n"
						  "\tint sx = ux.i>>63;\n"
						  "\tuint64_t i;\n"
						  "\n"
						  "\t/* in the followings uxi should be ux.i, but then gcc wrongly adds */\n"
						  "\t/* float load/store to inner loops ruining performance and code size */\n"
						  "\tuint64_t uxi = ux.i;\n"
						  "\n"
						  "\tif (uy.i<<1 == 0 || isnan(y) || ex == 0x7ff)\n"
						  "\t\treturn (x*y)/(x*y);\n"
						  "\tif (uxi<<1 <= uy.i<<1) {\n"
						  "\t\tif (uxi<<1 == uy.i<<1)\n"
						  "\t\t\treturn 0*x;\n"
						  "\t\treturn x;\n"
						  "\t}\n"
						  "\n"
						  "\t/* normalize x and y */\n"
						  "\tif (!ex) {\n"
						  "\t\tfor (i = uxi<<12; i>>63 == 0; ex--, i <<= 1);\n"
						  "\t\tuxi <<= -ex + 1;\n"
						  "\t} else {\n"
						  "\t\tuxi &= -1ULL >> 12;\n"
						  "\t\tuxi |= 1ULL << 52;\n"
						  "\t}\n"
						  "\tif (!ey) {\n"
						  "\t\tfor (i = uy.i<<12; i>>63 == 0; ey--, i <<= 1);\n"
						  "\t\tuy.i <<= -ey + 1;\n"
						  "\t} else {\n"
						  "\t\tuy.i &= -1ULL >> 12;\n"
						  "\t\tuy.i |= 1ULL << 52;\n"
						  "\t}\n"
						  "\n"
						  "\t/* x mod y */\n"
						  "\tfor (; ex > ey; ex--) {\n"
						  "\t\ti = uxi - uy.i;\n"
						  "\t\tif (i >> 63 == 0) {\n"
						  "\t\t\tif (i == 0)\n"
						  "\t\t\t\treturn 0*x;\n"
						  "\t\t\tuxi = i;\n"
						  "\t\t}\n"
						  "\t\tuxi <<= 1;\n"
						  "\t}\n"
						  "\ti = uxi - uy.i;\n"
						  "\tif (i >> 63 == 0) {\n"
						  "\t\tif (i == 0)\n"
						  "\t\t\treturn 0*x;\n"
						  "\t\tuxi = i;\n"
						  "\t}\n"
						  "\tfor (; uxi>>52 == 0; uxi <<= 1, ex--);\n"
						  "\n"
						  "\t/* scale result */\n"
						  "\tif (ex > 0) {\n"
						  "\t\tuxi -= 1ULL << 52;\n"
						  "\t\tuxi |= (uint64_t)ex << 52;\n"
						  "\t} else {\n"
						  "\t\tuxi >>= -ex + 1;\n"
						  "\t}\n"
						  "\tuxi |= (uint64_t)sx << 63;\n"
						  "\tux.i = uxi;\n"
						  "\treturn ux.f;\n"
						  "}\n"
						  "\n"
						  "\n"
						  "template<typename T, Size R, Size C>\n"
						  "class Matrix\n"
						  "{\n"
						  "\tstatic_assert(R > 0);\n"
						  "\tstatic_assert(C > 0);\n"
						  "public:\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tconstexpr Size GetRows() const\n"
						  "\t{\n"
						  "\t\treturn R;\n"
						  "\t}\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tconstexpr Size  GetColumns() const\n"
						  "\t{\n"
						  "\t\treturn C;\n"
						  "\t}\n"
						  "\n"
						  "\tT operator[](Size i) const\n"
						  "\t{\n"
						  "\t\treturn _values[i];\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C> CalculateInverse() const\n"
						  "\t{\n"
						  "\t\tauto det = CalculateDeterminant();\n"
						  "\t\tif (det < 1e-8) return Identity();\n"
						  "\n"
						  "\t\tauto adJoint = CalculateCofactors().CalculateTranspose();\n"
						  "\t\treturn adJoint * (1.0 / det);\n"
						  "\t}\n"
						  "\n"
						  "\tvoid CalculateInverse(Matrix<T, R, C>& out) const\n"
						  "\t{\n"
						  "\t\tauto det = CalculateDeterminant();\n"
						  "\t\tif (det < 1e-8)\n"
						  "\t\t{\n"
						  "\t\t\tout = Identity();\n"
						  "\t\t\treturn;\n"
						  "\t\t}\n"
						  "\n"
						  "\t\tMatrix<T, R, C> tmp;\n"
						  "\t\tCalculateCofactors(tmp);\n"
						  "\t\ttmp.CalculateTranspose(out);\n"
						  "\t\tout *= (1.0 / det);\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C> CalculateMinor() const\n"
						  "\t{\n"
						  "\t\tMatrix<T, R, C> out;\n"
						  "\t\tfor (Size i = 0; i < R; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tfor (Size j = 0; j < C; ++j)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tout.Get(i, j) = CalculateRemovedRowColumn(i, j).CalculateDeterminant();\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\n"
						  "\t\treturn out;\n"
						  "\t}\n"
						  "\n"
						  "\tvoid CalculateMinor(Matrix<T, R, C>& out) const\n"
						  "\t{\n"
						  "\t\tMatrix<T, R - 1, C - 1> tmp;\n"
						  "\t\tfor (Size i = 0; i < R; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tfor (Size j = 0; j < C; ++j)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tCalculateRemovedRowColumn(i, j, tmp);\n"
						  "\t\t\t\tout.Get(i, j) = tmp.CalculateDeterminant();\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C> CalculateCofactors() const\n"
						  "\t{\n"
						  "\t\tauto minor = CalculateMinor();\n"
						  "\n"
						  "\t\tfor (Size i = 0, s = 1; i < R; ++i, ++s)\n"
						  "\t\t{\n"
						  "\t\t\tfor (Size j = s % 2; j < C; j += 2)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tminor.Get(i, j) = -minor.Get(i, j);\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\t\treturn minor;\n"
						  "\t}\n"
						  "\n"
						  "\tvoid CalculateCofactors(Matrix<T, R, C>& out) const\n"
						  "\t{\n"
						  "\t\tCalculateMinor(out);\n"
						  "\n"
						  "\t\tfor (Size i = 0, s = 1; i < R; ++i, ++s)\n"
						  "\t\t{\n"
						  "\t\t\tfor (Size j = s % 2; j < C; j += 2)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tout.Get(i, j) = -out.Get(i, j);\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C> CalculateTranspose() const\n"
						  "\t{\n"
						  "\t\tstatic_assert(R == C);\n"
						  "\t\tMatrix<T, C, R> out;\n"
						  "\n"
						  "\t\tfor (Size i = 0; i < R; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tfor (Size j = i; j < C; ++j)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tout.Get(i, j) = Get(j, i);\n"
						  "\t\t\t\tout.Get(j, i) = Get(i, j);\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\n"
						  "\t\treturn out;\n"
						  "\t}\n"
						  "\n"
						  "\tvoid CalculateTranspose(Matrix<T, R, C>& out) const\n"
						  "\t{\n"
						  "\t\tstatic_assert(R == C);\n"
						  "\n"
						  "\t\tfor (Size i = 0; i < R; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tfor (Size j = i; j < C; ++j)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tout.Get(i, j) = Get(j, i);\n"
						  "\t\t\t\tout.Get(j, i) = Get(i, j);\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\t}\n"
						  "\n"
						  "\tvoid CalculateRemovedRowColumn(Size row, Size column, Matrix<T, R - 1, C - 1>& out) const\n"
						  "\t{\n"
						  "\t\tfor (Size i = 0, io = 0; i < R; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tif (i == row) continue;\n"
						  "\t\t\tfor (Size j = 0, jo = 0; j < C; ++j)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tif (j == column) continue;\n"
						  "\n"
						  "\t\t\t\tout.Get(io, jo) = Get(i, j);\n"
						  "\n"
						  "\t\t\t\tjo++;\n"
						  "\t\t\t}\n"
						  "\t\t\tio++;\n"
						  "\t\t}\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R - 1, C - 1> CalculateRemovedRowColumn(Size row, Size column) const\n"
						  "\t{\n"
						  "\t\tMatrix<T, R - 1, C - 1> out;\n"
						  "\t\tCalculateRemovedRowColumn(row, column, out);\n"
						  "\t\treturn out;\n"
						  "\t}\n"
						  "\n"
						  "\tT CalculateDeterminant() const\n"
						  "\t{\n"
						  "\t\tstatic_assert(R == C);\n"
						  "\n"
						  "\t\tif constexpr (R > 2)\n"
						  "\t\t{\n"
						  "\t\t\tMatrix<T, R - 1, C - 1> tmp;\n"
						  "\t\t\tT det = 0.0;\n"
						  "\t\t\tT sign = 1.0;\n"
						  "\t\t\tfor (Size i = 0; i < C; ++i)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tCalculateRemovedRowColumn(0, i, tmp);\n"
						  "\n"
						  "\t\t\t\tdet += sign * Get(0, i) * tmp.CalculateDeterminant();\n"
						  "\n"
						  "\t\t\t\tsign = -sign;\n"
						  "\t\t\t}\n"
						  "\n"
						  "\t\t\treturn det;\n"
						  "\t\t}\n"
						  "\t\telse\n"
						  "\t\t{\n"
						  "\t\t\treturn (_values[0] * _values[3]) - (_values[1] * _values[2]);\n"
						  "\t\t}\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C> operator-(T value) const\n"
						  "\t{\n"
						  "\t\tauto copy = *this;\n"
						  "\t\tfor (Size i = 0; i < R * C; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tcopy._values[i] -= value;\n"
						  "\t\t}\n"
						  "\t\treturn copy;\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C>& operator-=(T value) const\n"
						  "\t{\n"
						  "\t\tfor (Size i = 0; i < R * C; ++i)\n"
						  "\t\t{\n"
						  "\t\t\t_values[i] -= value;\n"
						  "\t\t}\n"
						  "\t\treturn *this;\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C> operator+(T value) const\n"
						  "\t{\n"
						  "\t\tauto copy = *this;\n"
						  "\t\tfor (Size i = 0; i < R * C; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tcopy._values[i] += value;\n"
						  "\t\t}\n"
						  "\t\treturn copy;\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C>& operator+=(T value) const\n"
						  "\t{\n"
						  "\t\tfor (Size i = 0; i < R * C; ++i)\n"
						  "\t\t{\n"
						  "\t\t\t_values[i] += value;\n"
						  "\t\t}\n"
						  "\t\treturn *this;\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C>& operator*=(T value)\n"
						  "\t{\n"
						  "\t\tfor (Size i = 0; i < R * C; ++i)\n"
						  "\t\t{\n"
						  "\t\t\t_values[i] *= value;\n"
						  "\t\t}\n"
						  "\t\treturn *this;\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C> operator*(T value) const\n"
						  "\t{\n"
						  "\t\tauto copy = *this;\n"
						  "\t\tfor (Size i = 0; i < R * C; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tcopy._values[i] *= value;\n"
						  "\t\t}\n"
						  "\t\treturn copy;\n"
						  "\t}\n"
						  "\n"
						  "\ttemplate<Size Oc>\n"
						  "\tMatrix<T, R, Oc> operator*(const Matrix<T, C, Oc>& other) const\n"
						  "\t{\n"
						  "\t\tMatrix<T, R, Oc> returnMatrix;\n"
						  "\t\tfor (Size i = 0; i < R; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tfor (Size j = 0; j < Oc; ++j)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tT product = 0.0;\n"
						  "\t\t\t\tfor (Size k = 0; k < C; ++k)\n"
						  "\t\t\t\t{\n"
						  "\t\t\t\t\tproduct += Get(i, k) * other.Get(k, j);\n"
						  "\t\t\t\t}\n"
						  "\t\t\t\treturnMatrix.Get(i, j) = product;\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\n"
						  "\t\treturn returnMatrix;\n"
						  "\t}\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tdouble Get(Size r, Size c) const\n"
						  "\t{\n"
						  "\t\treturn _values[r * C + c];\n"
						  "\t}\n"
						  "\n"
						  "\tdouble& Get(Size r, Size c)\n"
						  "\t{\n"
						  "\t\treturn _values[r * C + c];\n"
						  "\t}\n"
						  "\n"
						  "\tconstexpr Matrix()\n"
						  "\t\t\t:_values{ 0.0 }\n"
						  "\t{\n"
						  "\n"
						  "\t}\n"
						  "\n"
						  "\tstatic constexpr Matrix<T, R, C> Identity()\n"
						  "\t{\n"
						  "\t\tMatrix<T, R, C> ret;\n"
						  "\n"
						  "\t\tfor (Size i = 0; i < R * C; i += C + 1)\n"
						  "\t\t{\n"
						  "\t\t\tret._values[i] = 1.0;\n"
						  "\t\t}\n"
						  "\n"
						  "\t\treturn ret;\n"
						  "\t}\n"
						  "\n"
						  "\ttemplate<class ... TValue>\n"
						  "\tstatic constexpr Matrix<T, R, C> WithOnes(const TValue... values)\n"
						  "\t{\n"
						  "\t\tMatrix<T, R, C> ret{ values... };\n"
						  "\n"
						  "\t\tauto argumentCount = sizeof...(values);\n"
						  "\t\tif (argumentCount >= R * C)\n"
						  "\t\t{\n"
						  "\t\t\treturn ret;\n"
						  "\t\t}\n"
						  "\t\tfor (Size i = argumentCount; i < (R * C) - argumentCount; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tret._values[i] = 1.0;\n"
						  "\t\t}\n"
						  "\n"
						  "\t\treturn ret;\n"
						  "\t}\n"
						  "\n"
						  "\ttemplate<class ... TValue>\n"
						  "\tconstexpr explicit Matrix(const TValue... values)\n"
						  "\t\t\t:_values{ values... }\n"
						  "\t{\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix(const Matrix<T, R, C>&) = default;\n"
						  "\tMatrix& operator=(const Matrix<T, R, C>&) = default;\n"
						  "\tMatrix(Matrix<T, R, C>&&) noexcept = default;\n"
						  "\tMatrix& operator=(Matrix<T, R, C>&&) noexcept = default;\n"
						  "\t~Matrix() = default;\n"
						  "private:\n"
						  "\tT _values[R * C];\n"
						  "\n"
						  "\tfriend class Matrix<T, C, R>;\n"
						  "};\n"
						  "\n"
						  "template<typename T>\n"
						  "class Color\n"
						  "{\n"
						  "public:\n"
						  "\n"
						  "\tColor<T> operator*(const T v) const\n"
						  "\t{\n"
						  "\t\treturn {\n"
						  "\t\t\t\t_r * v,\n"
						  "\t\t\t\t_g * v,\n"
						  "\t\t\t\t_b * v,\n"
						  "\t\t};\n"
						  "\t}\n"
						  "\n"
						  "\tColor<T>& operator*=(const T& v)\n"
						  "\t{\n"
						  "\t\t_r *= v;\n"
						  "\t\t_g *= v;\n"
						  "\t\t_b *= v;\n"
						  "\t\treturn *this;\n"
						  "\t}\n"
						  "\n"
						  "\tColor<T>& operator*=(const Color<T>& other)\n"
						  "\t{\n"
						  "\t\t_r *= other._r;\n"
						  "\t\t_g *= other._g;\n"
						  "\t\t_b *= other._b;\n"
						  "\t\treturn *this;\n"
						  "\t}\n"
						  "\n"
						  "\tColor<T>& operator+=(const Color<T>& other)\n"
						  "\t{\n"
						  "\t\t_r += other._r;\n"
						  "\t\t_g += other._g;\n"
						  "\t\t_b += other._b;\n"
						  "\t\treturn *this;\n"
						  "\t}\n"
						  "\n"
						  "\tColor<T> operator+(const Color<T>& other) const\n"
						  "\t{\n"
						  "\t\treturn {\n"
						  "\t\t\t\t_r + other._r,\n"
						  "\t\t\t\t_g + other._g,\n"
						  "\t\t\t\t_b + other._b,\n"
						  "\t\t};\n"
						  "\t}\n"
						  "\n"
						  "\tColor<T> operator*(const Color<T>& other) const\n"
						  "\t{\n"
						  "\t\treturn {\n"
						  "\t\t\t\t_r * other._r,\n"
						  "\t\t\t\t_g * other._g,\n"
						  "\t\t\t\t_b * other._b,\n"
						  "\t\t};\n"
						  "\t}\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tconstexpr T R() const\n"
						  "\t{\n"
						  "\t\treturn _r;\n"
						  "\t}\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tT& R()\n"
						  "\t{\n"
						  "\t\treturn _r;\n"
						  "\t}\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tconstexpr T G() const\n"
						  "\t{\n"
						  "\t\treturn _g;\n"
						  "\t}\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tT& G()\n"
						  "\t{\n"
						  "\t\treturn _g;\n"
						  "\t}\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tconstexpr T B() const\n"
						  "\t{\n"
						  "\t\treturn _b;\n"
						  "\t}\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tT& B()\n"
						  "\t{\n"
						  "\t\treturn _b;\n"
						  "\t}\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tconstexpr T A() const\n"
						  "\t{\n"
						  "\t\treturn _a;\n"
						  "\t}\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tT& A()\n"
						  "\t{\n"
						  "\t\treturn _a;\n"
						  "\t}\n"
						  "\n"
						  "\tconstexpr Color()\n"
						  "\t\t\t:_r(0.0), _g(0.0), _b(0.0), _a(1.0)\n"
						  "\t{\n"
						  "\n"
						  "\t}\n"
						  "\n"
						  "\tconstexpr Color(const T r, const T g, const T b)\n"
						  "\t\t\t:_r(r), _g(g), _b(b), _a(1.0)\n"
						  "\t{\n"
						  "\t}\n"
						  "\n"
						  "\tconstexpr Color(const T r, const T g, const T b, const T a)\n"
						  "\t\t\t:_r(r), _g(g), _b(b), _a(a)\n"
						  "\t{\n"
						  "\t}\n"
						  "\n"
						  "\tColor(const Color<T>&) = default;\n"
						  "\tColor& operator=(const Color<T>&) = default;\n"
						  "\tColor(Color<T>&&) noexcept = default;\n"
						  "\tColor& operator=(Color<T>&&) noexcept = default;\n"
						  "\t~Color() = default;\n"
						  "private:\n"
						  "\tT _r;\n"
						  "\tT _g;\n"
						  "\tT _b;\n"
						  "\tT _a;\n"
						  "};\n"
						  "\n"
						  "\n"
						  "template<typename T>\n"
						  "class Vector3\n"
						  "{\n"
						  "public:\n"
						  "\n"
						  "\tconstexpr T operator[](const Size i) const\n"
						  "\t{\n"
						  "\t\treturn ((T*)&_x)[i];\n"
						  "\t}\n"
						  "\n"
						  "\tconstexpr T X() const\n"
						  "\t{\n"
						  "\t\treturn _x;\n"
						  "\t}\n"
						  "\n"
						  "\tconstexpr T Y() const\n"
						  "\t{\n"
						  "\t\treturn _y;\n"
						  "\t}\n"
						  "\n"
						  "\tconstexpr T Z() const\n"
						  "\t{\n"
						  "\t\treturn _z;\n"
						  "\t}\n"
						  "\n"
						  "\ttemplate<Size R, Size C>\n"
						  "\tVector3<T>& Transform(const Matrix<T, R, C>& matrix)\n"
						  "\t{\n"
						  "\t\tauto m = Matrix<T, R, 1>::WithOnes(_x, _y, _z);\n"
						  "\t\tauto multiple = matrix * m;\n"
						  "\t\t_x = multiple[0];\n"
						  "\t\t_y = multiple[1];\n"
						  "\t\t_z = multiple[2];\n"
						  "\t\treturn *this;\n"
						  "\t}\n"
						  "\n"
						  "\tconstexpr T LengthSquared() const\n"
						  "\t{\n"
						  "\t\treturn (_x * _x) + (_y * _y) + (_z * _z);\n"
						  "\t}\n"
						  "\n"
						  "\tconstexpr T Length() const\n"
						  "\t{\n"
						  "\t\treturn sqrt(LengthSquared());\n"
						  "\t}\n"
						  "\n"
						  "\tVector3<T>& operator+=(const Vector3<T>& other)\n"
						  "\t{\n"
						  "\t\t_x += other._x;\n"
						  "\t\t_y += other._y;\n"
						  "\t\t_z += other._z;\n"
						  "\t\treturn *this;\n"
						  "\t}\n"
						  "\n"
						  "\tVector3<T>& operator-=(const Vector3<T>& other)\n"
						  "\t{\n"
						  "\t\t_x -= other._x;\n"
						  "\t\t_y -= other._y;\n"
						  "\t\t_z -= other._z;\n"
						  "\t\treturn *this;\n"
						  "\t}\n"
						  "\n"
						  "\tVector3<T>& operator*=(T scale)\n"
						  "\t{\n"
						  "\t\t_x *= scale;\n"
						  "\t\t_y *= scale;\n"
						  "\t\t_z *= scale;\n"
						  "\t\treturn *this;\n"
						  "\t}\n"
						  "\n"
						  "\tVector3<T> operator+(const Vector3<T>& other) const\n"
						  "\t{\n"
						  "\t\treturn {\n"
						  "\t\t\t\t_x + other._x,\n"
						  "\t\t\t\t_y + other._y,\n"
						  "\t\t\t\t_z + other._z,\n"
						  "\t\t};\n"
						  "\t}\n"
						  "\n"
						  "\tVector3<T> operator-(const Vector3<T>& other) const\n"
						  "\t{\n"
						  "\t\treturn {\n"
						  "\t\t\t\t_x - other._x,\n"
						  "\t\t\t\t_y - other._y,\n"
						  "\t\t\t\t_z - other._z,\n"
						  "\t\t};\n"
						  "\t}\n"
						  "\n"
						  "\tT DotProduct(const Vector3<T>& other) const\n"
						  "\t{\n"
						  "\t\treturn (_x * other._x) + (_y * other._y) + (_z * other._z);\n"
						  "\t}\n"
						  "\n"
						  "\tVector3<T> operator*(const Vector3<T>& other) const\n"
						  "\t{\n"
						  "\t\treturn {\n"
						  "\t\t\t\t_x * other._x,\n"
						  "\t\t\t\t_y * other._y,\n"
						  "\t\t\t\t_z * other._z,\n"
						  "\t\t};\n"
						  "\t}\n"
						  "\n"
						  "\tVector3<T> Cross(const Vector3<T>& other) const\n"
						  "\t{\n"
						  "\t\treturn {\n"
						  "\t\t\t\t(_y * other._z) - (_z * other._y),\n"
						  "\t\t\t\t(_z * other._x) - (_x * other._z),\n"
						  "\t\t\t\t(_x * other._y) - (_y * other._x)\n"
						  "\t\t};\n"
						  "\t}\n"
						  "\n"
						  "\tVector3<T> operator*(T scale) const\n"
						  "\t{\n"
						  "\t\treturn {\n"
						  "\t\t\t\t_x * scale,\n"
						  "\t\t\t\t_y * scale,\n"
						  "\t\t\t\t_z * scale,\n"
						  "\t\t};\n"
						  "\t}\n"
						  "\n"
						  "\tVector3<T>& Normalize()\n"
						  "\t{\n"
						  "\t\tauto length = Length();\n"
						  "\n"
						  "\t\t_x /= length;\n"
						  "\t\t_y /= length;\n"
						  "\t\t_z /= length;\n"
						  "\t\treturn *this;\n"
						  "\t}\n"
						  "\n"
						  "\tconstexpr Vector3<T> Normalized() const\n"
						  "\t{\n"
						  "\t\tauto length = Length();\n"
						  "\n"
						  "\t\treturn {\n"
						  "\t\t\t\t_x / length,\n"
						  "\t\t\t\t_y / length,\n"
						  "\t\t\t\t_z / length\n"
						  "\t\t};\n"
						  "\t}\n"
						  "\n"
						  "\tconstexpr Vector3()\n"
						  "\t\t\t:_x(0.0), _y(0.0), _z(0.0)\n"
						  "\t{\n"
						  "\t}\n"
						  "\n"
						  "\tconstexpr Vector3(T x, T y, T z)\n"
						  "\t\t\t:_x(x), _y(y), _z(z)\n"
						  "\t{\n"
						  "\t}\n"
						  "\n"
						  "\tVector3(const Vector3<T>&) = default;\n"
						  "\tVector3& operator=(const Vector3<T>&) = default;\n"
						  "\tVector3(Vector3<T>&&) noexcept = default;\n"
						  "\tVector3& operator=(Vector3<T>&&) noexcept = default;\n"
						  "\t~Vector3() = default;\n"
						  "protected:\n"
						  "\tT _x;\n"
						  "\tT _y;\n"
						  "\tT _z;\n"
						  "};\n"
						  "\n"
						  "template<typename T>\n"
						  "class ShaderColor: public Color<T>\n"
						  "{\n"
						  "public:\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tT GetReflection() const\n"
						  "\t{\n"
						  "\t\treturn _reflection;\n"
						  "\t}\n"
						  "\n"
						  "\tShaderColor()\n"
						  "\t\t\t:Color<T>(), _reflection(0.0)\n"
						  "\t{\n"
						  "\n"
						  "\t}\n"
						  "\n"
						  "\tShaderColor(const T r, const T g, const T b, const T a)\n"
						  "\t\t\t:Color<T>(r, g, b, a), _reflection(0.0)\n"
						  "\t{\n"
						  "\t}\n"
						  "\n"
						  "\tShaderColor(const T r, const T g, const T b, const T a, T reflection)\n"
						  "\t\t\t:Color<T>(r, g, b, a), _reflection(reflection)\n"
						  "\t{\n"
						  "\t}\n"
						  "\n"
						  "private:\n"
						  "\tT _reflection;\n"
						  "};\n"
						  "\n"
						  "template<typename T>\n"
						  "using Shader = ShaderColor<T> (*)(const Vector3<T>& position);\n"
						  "\n"
						  "template<typename T>\n"
						  "class Light\n"
						  "{\n"
						  "public:\n"
						  "\n"
						  "\tconst Vector3<T>& GetLocation() const\n"
						  "\t{\n"
						  "\t\treturn _location;\n"
						  "\t}\n"
						  "\n"
						  "\tconst Color<T>& GetColor() const\n"
						  "\t{\n"
						  "\t\treturn _color;\n"
						  "\t}\n"
						  "\n"
						  "\tLight() = default;\n"
						  "\n"
						  "\tLight(const Vector3<T>& location, const Color<T>& color)\n"
						  "\t\t\t:_location(location), _color(color)\n"
						  "\t{\n"
						  "\t}\n"
						  "\n"
						  "private:\n"
						  "\tVector3<T> _location;\n"
						  "\tColor<T> _color;\n"
						  "};\n"
						  "\n"
						  "template<typename T>\n"
						  "class Triangle\n"
						  "{\n"
						  "public:\n"
						  "\n"
						  "\tconst Vector3<T>& GetNormal() const\n"
						  "\t{\n"
						  "\t\treturn _normal;\n"
						  "\t}\n"
						  "\n"
						  "\tT IntersectsRay(const Vector3<T>& origin, const Vector3<T>& direction, T near = 0.001,\n"
						  "\t\t\tT far = 1e+308) const\n"
						  "\t{\n"
						  "\t\tauto u = (_axis + 1) % 3;\n"
						  "\t\tauto v = (_axis + 2) % 3;\n"
						  "\t\tauto d = direction[_axis] + _nu * direction[u] + _nv * direction[v];\n"
						  "\t\tauto t = (_nd - origin[_axis] - _nu * origin[u] - _nv * origin[v]) / d;\n"
						  "\t\tif (t < near || t > far)\n"
						  "\t\t{\n"
						  "\t\t\treturn -1;\n"
						  "\t\t}\n"
						  "\t\tauto Pu = origin[u] + t * direction[u] - _eu;\n"
						  "\t\tauto Pv = origin[v] + t * direction[v] - _ev;\n"
						  "\t\tauto a2 = Pv * _nu1 + Pu * _nv1;\n"
						  "\t\tif (a2 < 0)\n"
						  "\t\t{\n"
						  "\t\t\treturn -1;\n"
						  "\t\t}\n"
						  "\t\tauto a3 = Pu * _nu2 + Pv * _nv2;\n"
						  "\t\tif (a3 < 0)\n"
						  "\t\t{\n"
						  "\t\t\treturn -1;\n"
						  "\t\t}\n"
						  "\n"
						  "\t\tif ((a2 + a3) > 1)\n"
						  "\t\t{\n"
						  "\t\t\treturn -1;\n"
						  "\t\t}\n"
						  "\t\treturn t;\n"
						  "\t}\n"
						  "\n"
						  "\tShader<T> GetShader() const\n"
						  "\t{\n"
						  "\t\treturn _shader;\n"
						  "\t}\n"
						  "\n"
						  "\tTriangle()\n"
						  "\t\t\t:_axis(0), _nu(0.0), _nv(0.0), _nd(0.0), _eu(0.0), _nu1(0.0), _nv1(0.0), _nu2(0.0), _nv2(0.0)\n"
						  "\t{\n"
						  "\n"
						  "\t}\n"
						  "\n"
						  "\tTriangle(const Vector3<T>& a, const Vector3<T>& b, const Vector3<T>& c, Shader<T> shader = [](auto p){ return ShaderColor<T>(); })\n"
						  "\t\t\t:_a(a), _b(b), _c(c), _shader(shader), _axis(0), _nu(0.0), _nv(0.0), _nd(0.0), _eu(0.0), _nu1(0.0),\n"
						  "\t\t\t _nv1(0.0), _nu2(0.0), _nv2(0.0)\n"
						  "\t{\n"
						  "\t\tCalculate();\n"
						  "\t}\n"
						  "\n"
						  "\tTriangle(const Triangle<T>&) = default;\n"
						  "\tTriangle& operator=(const Triangle<T>&) = default;\n"
						  "\tTriangle(Triangle<T>&&) noexcept = default;\n"
						  "\tTriangle& operator=(Triangle<T>&&) noexcept = default;\n"
						  "\t~Triangle() = default;\n"
						  "private:\n"
						  "\tVector3<T> _a;\n"
						  "\tVector3<T> _b;\n"
						  "\tVector3<T> _c;\n"
						  "\tVector3<T> _normal;\n"
						  "\tShader<T> _shader;\n"
						  "\n"
						  "\tSize _axis;\n"
						  "\tT _nu;\n"
						  "\tT _nv;\n"
						  "\tT _nd;\n"
						  "\tT _eu;\n"
						  "\tT _ev;\n"
						  "\tT _nu1;\n"
						  "\tT _nv1;\n"
						  "\tT _nu2;\n"
						  "\tT _nv2;\n"
						  "\n"
						  "\tvoid Calculate()\n"
						  "\t{\n"
						  "\t\tauto edge1 = _c - _a;\n"
						  "\t\tauto edge2 = _b - _a;\n"
						  "\t\t_normal = edge1.Cross(edge2).Normalize();\n"
						  "\t\tauto normal = edge1.Cross(edge2);\n"
						  "\n"
						  "\t\tif (abs(normal.X()) > abs(normal.Y()))\n"
						  "\t\t{\n"
						  "\t\t\tif (abs(normal.X()) > abs(normal.Z()))\n"
						  "\t\t\t{\n"
						  "\t\t\t\t_axis = 0;\n"
						  "\t\t\t}\n"
						  "\t\t\telse\n"
						  "\t\t\t{\n"
						  "\t\t\t\t_axis = 2;\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\t\telse\n"
						  "\t\t{\n"
						  "\t\t\tif (abs(normal.Y()) > abs(normal.Z()))\n"
						  "\t\t\t{\n"
						  "\t\t\t\t_axis = 1;\n"
						  "\t\t\t}\n"
						  "\t\t\telse\n"
						  "\t\t\t{\n"
						  "\t\t\t\t_axis = 2;\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\n"
						  "\t\tauto u = (_axis + 1) % 3;\n"
						  "\t\tauto v = (_axis + 2) % 3;\n"
						  "\n"
						  "\t\tauto u1 = edge1[u];\n"
						  "\t\tauto v1 = edge1[v];\n"
						  "\n"
						  "\t\tauto u2 = edge2[u];\n"
						  "\t\tauto v2 = edge2[v];\n"
						  "\n"
						  "\t\t_normal = normal.Normalized();\n"
						  "\n"
						  "\t\t_nu = normal[u] / normal[_axis];\n"
						  "\t\t_nv = normal[v] / normal[_axis];\n"
						  "\t\t_nd = normal.DotProduct(_a) / normal[_axis];\n"
						  "\t\tauto det = u1 * v2 - v1 * u2;\n"
						  "\t\t_eu = _a[u];\n"
						  "\t\t_ev = _a[v];\n"
						  "\t\t_nu1 = u1 / det;\n"
						  "\t\t_nv1 = -v1 / det;\n"
						  "\t\t_nu2 = v2 / det;\n"
						  "\t\t_nv2 = -u2 / det;\n"
						  "\t}\n"
						  "};\n"
						  "\n"
						  "template<typename T, Size TS, Size LS>\n"
						  "class Scene\n"
						  "{\n"
						  "public:\n"
						  "\n"
						  "\tColor<T> Intersect(const Vector3<T>& origin, const Vector3<T>& direction, T near = 0.001,\n"
						  "\t\t\tT far = 1e+308) const\n"
						  "\t{\n"
						  "\t\tconst Triangle<T>* closest = nullptr;\n"
						  "\n"
						  "\t\tfor (auto& triangle : _triangles)\n"
						  "\t\t{\n"
						  "\t\t\tauto d = triangle.IntersectsRay(origin, direction, near, far);\n"
						  "\t\t\tif (d < 0.0 || d > far || d < near) continue;\n"
						  "\t\t\tfar = d;\n"
						  "\t\t\tclosest = &triangle;\n"
						  "\t\t}\n"
						  "\n"
						  "\t\tif (closest == nullptr) return _background;\n"
						  "\n"
						  "\t\tauto normal = closest->GetNormal();\n"
						  "\t\tauto hit = origin + (direction * far);\n"
						  "\n"
						  "\t\tif (direction.DotProduct(normal) > 0.0)\n"
						  "\t\t{\n"
						  "\t\t\tnormal = { -normal.X(), -normal.Y(), -normal.Z() };\n"
						  "\t\t}\n"
						  "\n"
						  "\t\tauto color = closest->GetShader()(hit);\n"
						  "\n"
						  "\t\tColor<T> reflected;\n"
						  "\t\tbool isReflected = false;\n"
						  "\t\tif (color.GetReflection() > 0.001)\n"
						  "\t\t{\n"
						  "\t\t\tauto reflection = (normal * (-2.0 * direction.DotProduct(normal))) + direction;\n"
						  "\t\t\treflected = Intersect(hit, reflection, 0.0001, 1000000);\n"
						  "\t\t\tisReflected = true;\n"
						  "\t\t\tif (color.GetReflection() >= 0.999999)\n"
						  "\t\t\t{\n"
						  "\t\t\t\treturn reflected;\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\n"
						  "\t\tauto l = _ambient;\n"
						  "\t\tfor (auto& light : _lights)\n"
						  "\t\t{\n"
						  "\t\t\tauto toLight = light.GetLocation() - hit;\n"
						  "\t\t\tauto distance = toLight.Length();\n"
						  "\t\t\ttoLight *= 1.0 / distance;\n"
						  "\t\t\tdistance -= 0.0001;\n"
						  "\n"
						  "\t\t\tif (IsBlocked(hit, toLight, distance)) continue;\n"
						  "\n"
						  "\t\t\tauto nl = normal.DotProduct(toLight);\n"
						  "\t\t\tif (nl > 0.0)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tl += light.GetColor() * nl;\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\t\tl = l * color;\n"
						  "\t\tif (isReflected)\n"
						  "\t\t{\n"
						  "\t\t\tl *= 1.0 - color.GetReflection();\n"
						  "\t\t\tl = l + (reflected * color.GetReflection());\n"
						  "\t\t}\n"
						  "\n"
						  "\t\treturn l;\n"
						  "\t}\n"
						  "\n"
						  "\tvoid SetAmbient(const Color<T>& color)\n"
						  "\t{\n"
						  "\t\t_ambient = color;\n"
						  "\t}\n"
						  "\n"
						  "//\ttemplate<typename ... R>\n"
						  "//\tvoid SetLights(R&& ... lights)\n"
						  "//\t{\n"
						  "//\t\t_lights = {lights...};\n"
						  "//\t}\n"
						  "//\n"
						  "//\ttemplate<typename ... R>\n"
						  "//\tvoid SetTriangles(R&& ... triangles)\n"
						  "//\t{\n"
						  "////\t\tfor (Size i = 0; i < sizeof...(R); ++i)\n"
						  "////\t\t{\n"
						  "////\t\t\t_triangles[i] = triangles...[i];\n"
						  "////\t\t}\n"
						  "//\t\t_triangles = { triangles... };\n"
						  "//\t}\n"
						  "\n"
						  "//\tScene()\n"
						  "//\t\t\t:_background(0.8, 0.8, 1.0)\n"
						  "//\t{\n"
						  "//\n"
						  "//\t}\n"
						  "\n"
						  "\tScene(Triangle<T> triangles[TS], Light<T> lights[LS])\n"
						  "\t\t\t: _background(0.8, 0.8, 1.0)\n"
						  "\t{\n"
						  "\t\tmemcpy(_triangles, triangles, sizeof(Triangle<T>) * TS);\n"
						  "\t\tmemcpy(_lights, lights, sizeof(Light<T>) * LS);\n"
						  "\t}\n"
						  "\n"
						  "\n"
						  "private:\n"
						  "\tTriangle<T> _triangles[TS];\n"
						  "\tLight<T> _lights[LS];\n"
						  "\tColor<T> _ambient;\n"
						  "\tColor<T> _background;\n"
						  "\n"
						  "\tbool IsBlocked(const Vector3<T>& origin, const Vector3<T>& direction, T far) const\n"
						  "\t{\n"
						  "\t\tT near = 0.0001;\n"
						  "\t\tconst Triangle<T>* closest = nullptr;\n"
						  "\t\tfor (auto& triangle : _triangles)\n"
						  "\t\t{\n"
						  "\t\t\tauto d = triangle.IntersectsRay(origin, direction, near, far);\n"
						  "\t\t\tif (d < 0.0 || d > far || d < near) continue;\n"
						  "\t\t\treturn true;\n"
						  "\t\t}\n"
						  "\n"
						  "\t\treturn false;\n"
						  "\t}\n"
						  "};\n"
						  "\n"
						  "class SceneCreator\n"
						  "{\n"
						  "public:\n"
						  "\ttemplate<typename T>\n"
						  "\tstatic Scene<T, 14, 3> GenerateScene()\n"
						  "\t{\n"
						  "\t\tauto tfl = Vector3<T>(-10, 10, -10);\n"
						  "\t\tauto tfr = Vector3<T>(10, 10, -10);\n"
						  "\t\tauto tbl = Vector3<T>(-10, 10, 10);\n"
						  "\t\tauto tbr = Vector3<T>(10, 10, 10);\n"
						  "\t\tauto bfl = Vector3<T>(-10, -10, -10);\n"
						  "\t\tauto bfr = Vector3<T>(10, -10, -10);\n"
						  "\t\tauto bbl = Vector3<T>(-10, -10, 10);\n"
						  "\t\tauto bbr = Vector3<T>(10, -10, 10);\n"
						  "\n"
						  "\t\tauto cubeShader = [](auto p)\n"
						  "\t\t{ return ShaderColor<T>(0.7, 0.7, 0.7, 1.0, 0.0); };\n"
						  "\n"
						  "\t\tauto ffl = Vector3<T>(-1000.0, -30.0, -1000.0);\n"
						  "\t\tauto ffr = Vector3<T>(1000.0, -30.0, -1000.0);\n"
						  "\t\tauto fbl = Vector3<T>(-1000.0, -30.0, 1000.0);\n"
						  "\t\tauto fbr = Vector3<T>(1000.0, -30.0, 1000.0);\n"
						  "\n"
						  "\t\t// floor\n"
						  "\n"
						  "\t\tauto floorShader = [](auto p)\n"
						  "\t\t{\n"
						  "\t\t\tT x = fmod(p.X() / 32.0, 2.0);\n"
						  "\t\t\tx+=2;\n"
						  "\t\t\tx = fmod(x, 2.0);\n"
						  "\n"
						  "\t\t\tT z = p.Z() / 32.0 + 0.3;\n"
						  "\t\t\tz = fmod(z, 2.0);\n"
						  "\t\t\tz+=2;\n"
						  "\t\t\tz = fmod(z, 2.0);\n"
						  "\n"
						  "\t\t\tif (x < 1.0 != z < 1.0)\n"
						  "\t\t\t{\n"
						  "\t\t\t\treturn ShaderColor<T>{ 0.4, 0.4, 0.4, 1.0, 1.0 };\n"
						  "\t\t\t}\n"
						  "\t\t\telse\n"
						  "\t\t\t{\n"
						  "\t\t\t\treturn ShaderColor<T>{ 0.0, 0.4, 0.0, 1.0 };\n"
						  "\t\t\t}\n"
						  "\t\t};\n"
						  "\n"
						  "\t\tTriangle<T> triangles[] = {\n"
						  "\t\t\t\t//front\n"
						  "\t\t\t\tTriangle<T>(tfl, tfr, bfr, cubeShader),\n"
						  "\t\t\t\tTriangle<T>(tfl, bfr, bfl, cubeShader),\n"
						  "\n"
						  "\t\t\t\t//back\n"
						  "\t\t\t\tTriangle<T>(tbl, tbr, bbr, cubeShader),\n"
						  "\t\t\t\tTriangle<T>(tbl, bbr, bbl, cubeShader),\n"
						  "\n"
						  "\t\t\t\t//left\n"
						  "\t\t\t\tTriangle<T>(tbl, tfl, bbl, cubeShader),\n"
						  "\t\t\t\tTriangle<T>(tfl, bfl, bbl, cubeShader),\n"
						  "\n"
						  "\t\t\t\t//right\n"
						  "\t\t\t\tTriangle<T>(tbr, tfr, bbr, cubeShader),\n"
						  "\t\t\t\tTriangle<T>(tfr, bfr, bbr, cubeShader),\n"
						  "\n"
						  "\t\t\t\t//top\n"
						  "\t\t\t\tTriangle<T>(tbl, tbr, tfr, cubeShader),\n"
						  "\t\t\t\tTriangle<T>(tbl, tfr, tfl, cubeShader),\n"
						  "\n"
						  "\t\t\t\t//bottom\n"
						  "\t\t\t\tTriangle<T>(bbl, bbr, bfr, cubeShader),\n"
						  "\t\t\t\tTriangle<T>(bbl, bfr, bfl, cubeShader),\n"
						  "\n"
						  "\t\t\t\tTriangle<T>(fbl, fbr, ffr, floorShader),\n"
						  "\t\t\t\tTriangle<T>(fbl, ffr, ffl, floorShader)\n"
						  "\t\t};\n"
						  "\n"
						  "\t\tLight<T> lights[] = {\n"
						  "\t\t\t\tLight<T>(\n"
						  "\t\t\t\t\t\t{ 20.0, 38.0, -22.0 },\n"
						  "\t\t\t\t\t\t{ 0.7, 0.3, 0.3 }\n"
						  "\t\t\t\t),\n"
						  "\t\t\t\tLight<T>(\n"
						  "\t\t\t\t\t\t{ -23.0, 40.0, 17.0 },\n"
						  "\t\t\t\t\t\t{ 0.7, 0.3, 0.3 }\n"
						  "\t\t\t\t),\n"
						  "\t\t\t\tLight<T>(\n"
						  "\t\t\t\t\t\t{ 23.0, 20.0, 17.0 },\n"
						  "\t\t\t\t\t\t{ 0.7, 0.7, 0.7 }\n"
						  "\t\t\t\t)\n"
						  "\t\t};\n"
						  "\t\t// cube\n"
						  "\t\tScene<T, 14, 3> scene = Scene<T, 14, 3>(triangles, lights);\n"
						  "\t\tscene.SetAmbient({ 0.1, 0.1, 0.1 });\n"
						  "\n"
						  "\t\treturn scene;\n"
						  "\t}\n"
						  "};\n"
						  "\n"
						  "template<typename T>\n"
						  "class Ray\n"
						  "{\n"
						  "public:\n"
						  "\tconst Vector3<T>& GetOrigin() const\n"
						  "\t{\n"
						  "\t\treturn _origin;\n"
						  "\t}\n"
						  "\n"
						  "\tconst Vector3<T>& GetDirection() const\n"
						  "\t{\n"
						  "\t\treturn _direction;\n"
						  "\t}\n"
						  "\n"
						  "\n"
						  "\tRay() = default;\n"
						  "\n"
						  "\tRay(const Vector3<T>& origin, const Vector3<T>& direction)\n"
						  "\t\t\t:_origin(origin), _direction(direction)\n"
						  "\t{\n"
						  "\t}\n"
						  "\n"
						  "\tRay(const Ray<T>&) = default;\n"
						  "\tRay& operator=(const Ray<T>&) = default;\n"
						  "\tRay(Ray<T>&&) noexcept = default;\n"
						  "\tRay& operator=(Ray<T>&&) noexcept = default;\n"
						  "\t~Ray() = default;\n"
						  "private:\n"
						  "\tVector3<T> _origin;\n"
						  "\tVector3<T> _direction;\n"
						  "};\n"
						  "\n"
						  "template<typename T, Size W, Size H>\n"
						  "class FrameBuffer\n"
						  "{\n"
						  "public:\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tSize GetHeight() const\n"
						  "\t{\n"
						  "\t\treturn H;\n"
						  "\t}\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tSize GetWidth() const\n"
						  "\t{\n"
						  "\t\treturn W;\n"
						  "\t}\n"
						  "\n"
						  "\tconst Color<T>& Get(Size i) const\n"
						  "\t{\n"
						  "\t\treturn _pixels[i];\n"
						  "\t}\n"
						  "\n"
						  "\tconst Color<T>& Get(Size x, Size y) const\n"
						  "\t{\n"
						  "\t\treturn _pixels[y * W + x];\n"
						  "\t}\n"
						  "\n"
						  "\tColor<T>& Get(Size x, Size y)\n"
						  "\t{\n"
						  "\t\treturn _pixels[y * W + x];\n"
						  "\t}\n"
						  "\n"
						  "\tFrameBuffer() = default;\n"
						  "\n"
						  "\tFrameBuffer(const FrameBuffer<T, W, H>&) = default;\n"
						  "\tFrameBuffer& operator=(const FrameBuffer<T, W, H>&) = default;\n"
						  "\n"
						  "\tFrameBuffer(FrameBuffer<T, W, H>&& other) noexcept\n"
						  "\t{\n"
						  "\t\t_pixels = other._pixels;\n"
						  "\t}\n"
						  "\n"
						  "\tFrameBuffer& operator=(FrameBuffer<T, W, H>&& other) noexcept\n"
						  "\t{\n"
						  "\t\t_pixels = other._pixels;\n"
						  "\n"
						  "\t\treturn *this;\n"
						  "\t}\n"
						  "\n"
						  "\t~FrameBuffer() = default;\n"
						  "private:\n"
						  "\tColor<T> _pixels[W * H];\n"
						  "};\n"
						  "\n"
						  "template<typename T>\n"
						  "class Camera\n"
						  "{\n"
						  "public:\n"
						  "\ttemplate<Size TS, Size LS, Size W, Size H>\n"
						  "\tvoid Render(const Scene<T, TS, LS>& scene, FrameBuffer<T, W, H>& frameBuffer) const\n"
						  "\t{\n"
						  "\t\tauto height = frameBuffer.GetHeight();\n"
						  "\t\tauto width = frameBuffer.GetWidth();\n"
						  "\n"
						  "\t\tRay<T> a, b;\n"
						  "\t\tfor (Size y = 0; y < height; ++y)\n"
						  "\t\t{\n"
						  "\t\t\tGenerateRayPair(y / T(height), a, b);\n"
						  "\t\t\tfor (Size x = 0; x < width; ++x)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tauto xp = x / T(width);\n"
						  "\t\t\t\tauto origin = (a.GetOrigin() * xp) + (b.GetOrigin() * (1.0 - xp));\n"
						  "\t\t\t\tauto direction = ((a.GetDirection() * xp) + (b.GetDirection() * (1.0 - xp))).Normalize();\n"
						  "\t\t\t\tauto l = scene.Intersect(origin, direction);\n"
						  "\t\t\t\tframeBuffer.Get(x, y) = l;\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\t}\n"
						  "\n"
						  "\tCamera() = default;\n"
						  "\tCamera(const Vector3<T>& origin, const Vector3<T>& lookAt, const Vector3<T>& up)\n"
						  "\t\t\t:_origin(origin)\n"
						  "\t{\n"
						  "\t\tauto zAxis = (lookAt - origin).Normalize();\n"
						  "\t\tauto xAxis = up.Cross(zAxis).Normalize();\n"
						  "\t\tauto yAxis = xAxis.Cross(Vector3<T>() - zAxis).Normalize();\n"
						  "\n"
						  "\t\tMatrix<T, 4, 4> matrix(\n"
						  "\t\t\t\txAxis.X(), xAxis.Y(), xAxis.Z(), 0.0,\n"
						  "\t\t\t\tyAxis.X(), yAxis.Y(), yAxis.Z(), 0.0,\n"
						  "\t\t\t\tzAxis.X(), zAxis.Y(), zAxis.Z(), 0.0,\n"
						  "\t\t\t\t0.0, 0.0, 0.0, 1.0\n"
						  "\t\t);\n"
						  "\n"
						  "\t\tmatrix = matrix.CalculateInverse();\n"
						  "\t\tmatrix.Get(0, 3) = 0.0;\n"
						  "\t\tmatrix.Get(1, 3) = 0.0;\n"
						  "\t\tmatrix.Get(2, 3) = 0.0;\n"
						  "\n"
						  "\t\t_directions[0] = Vector3<T>(-0.7, 0.7, 1.0)\n"
						  "\t\t\t\t.Normalize()\n"
						  "\t\t\t\t.Transform(matrix);\n"
						  "\n"
						  "\t\t_directions[1] = Vector3<T>(0.7, 0.7, 1.0)\n"
						  "\t\t\t\t.Normalize()\n"
						  "\t\t\t\t.Transform(matrix);\n"
						  "\n"
						  "\t\t_directions[2] = Vector3<T>(0.7, -0.7, 1.0)\n"
						  "\t\t\t\t.Normalize()\n"
						  "\t\t\t\t.Transform(matrix);\n"
						  "\n"
						  "\t\t_directions[3] = Vector3<T>(-0.7, -0.7, 1)\n"
						  "\t\t\t\t.Normalize()\n"
						  "\t\t\t\t.Transform(matrix);\n"
						  "\t}\n"
						  "\n"
						  "\tCamera(const Camera<T>&) = default;\n"
						  "\tCamera& operator=(const Camera<T>&) = default;\n"
						  "\tCamera(Camera<T>&&) noexcept = default;\n"
						  "\tCamera& operator=(Camera<T>&&) noexcept = default;\n"
						  "\t~Camera() = default;\n"
						  "private:\n"
						  "\tVector3<T> _origin;\n"
						  "\tVector3<T> _directions[4];\n"
						  "\n"
						  "\tvoid GenerateRayPair(T y, Ray<T>& a, Ray<T>& b) const\n"
						  "\t{\n"
						  "\t\ta = { _origin, (_directions[0] * y) + (_directions[3] * (1.0 - y)) };\n"
						  "\t\tb = { _origin, (_directions[1] * y) + (_directions[2] * (1.0 - y)) };\n"
						  "\t}\n"
						  "};\n"
						  "\n"
						  "extern \"C\" void Test3(FrameBuffer<double, 1024, 1024>& frameBuffer)\n"
						  "{\n"
						  "\tauto scene = SceneCreator::GenerateScene<double>();\n"
						  "\tauto camera = Camera<double>(\n"
						  "\t\t\t{ -40.0, 40.0, 40.0 },\n"
						  "\t\t\t{ 0.0, 0.0, 0.0 },\n"
						  "\t\t\t{ 0.0, 1.0, 0.0 });\n"
						  "\tcamera.Render(scene, frameBuffer);\n"
						  "}";

	void GenerateCppCodeTask::Prepare(SharedPtr<AbstractTaskData> inputData)
	{
		_outputData = std::move(inputData);
		_outputData->Allocate(sizeof(Source));
	}

	SharedPtr<AbstractTaskData> GenerateCppCodeTask::Finalize()
	{
		return std::move(_outputData);
	}

	Size GenerateCppCodeTask::GetProcessedDataSize() const
	{
		return _outputData->GetSize();
	}

	TaskInfo GenerateCppCodeTask::DoGetInfo() const
	{
		return {
				"C++ source generation",
				"Generates C++ source code",
				"Chars",
				"The byte generation throughput",
				ResultType::Throughput
		};
	}

	void GenerateCppCodeTask::DoRun()
	{
		std::memcpy(_outputData->GetData(), Source, sizeof(Source));
	}

	UniquePtr<Task> GenerateCppCodeTask::DoDuplicate() const
	{
		return std::make_unique<GenerateCppCodeTask>();
	}
} // Elpida