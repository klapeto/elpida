//
// Copyright (C) 2024. Ioannis Panagiotopoulos
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

//
// Created by klapeto on 20/12/2024.
//

#include "GenerateCppCodeTask.hpp"
#include <cstring>

namespace Elpida
{
	const char Source[] = "template<typename T, unsigned long R, unsigned long C>\n"
						  "class Matrix\n"
						  "{\n"
						  "\tstatic_assert(R > 0);\n"
						  "\tstatic_assert(C > 0);\n"
						  "public:\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tconstexpr unsigned long GetRows() const\n"
						  "\t{\n"
						  "\t\treturn R;\n"
						  "\t}\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tconstexpr unsigned long  GetColumns() const\n"
						  "\t{\n"
						  "\t\treturn C;\n"
						  "\t}\n"
						  "\n"
						  "\tT operator[](unsigned long i) const\n"
						  "\t{\n"
						  "\t\treturn _values[i];\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C> CalculateInverse() const\n"
						  "\t{\n"
						  "\t\tauto det = CalculateDeterminant();\n"
						  "\t\tif (det < 1e-8) return Identity();\n"
						  "\n"
						  "\t\tauto adJoint = CalculateCofactors().CalculateTranspose();\n"
						  "\t\treturn adJoint * (1.0 / det);\n"
						  "\t}\n"
						  "\n"
						  "\tvoid CalculateInverse(Matrix<T, R, C>& out) const\n"
						  "\t{\n"
						  "\t\tauto det = CalculateDeterminant();\n"
						  "\t\tif (det < 1e-8)\n"
						  "\t\t{\n"
						  "\t\t\tout = Identity();\n"
						  "\t\t\treturn;\n"
						  "\t\t}\n"
						  "\n"
						  "\t\tMatrix<T, R, C> tmp;\n"
						  "\t\tCalculateCofactors(tmp);\n"
						  "\t\ttmp.CalculateTranspose(out);\n"
						  "\t\tout *= (1.0 / det);\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C> CalculateMinor() const\n"
						  "\t{\n"
						  "\t\tMatrix<T, R, C> out;\n"
						  "\t\tfor (unsigned long i = 0; i < R; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tfor (unsigned long j = 0; j < C; ++j)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tout.Get(i, j) = CalculateRemovedRowColumn(i, j).CalculateDeterminant();\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\n"
						  "\t\treturn out;\n"
						  "\t}\n"
						  "\n"
						  "\tvoid CalculateMinor(Matrix<T, R, C>& out) const\n"
						  "\t{\n"
						  "\t\tMatrix<T, R - 1, C - 1> tmp;\n"
						  "\t\tfor (unsigned long i = 0; i < R; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tfor (unsigned long j = 0; j < C; ++j)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tCalculateRemovedRowColumn(i, j, tmp);\n"
						  "\t\t\t\tout.Get(i, j) = tmp.CalculateDeterminant();\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C> CalculateCofactors() const\n"
						  "\t{\n"
						  "\t\tauto minor = CalculateMinor();\n"
						  "\n"
						  "\t\tfor (unsigned long i = 0, s = 1; i < R; ++i, ++s)\n"
						  "\t\t{\n"
						  "\t\t\tfor (unsigned long j = s % 2; j < C; j += 2)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tminor.Get(i, j) = -minor.Get(i, j);\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\t\treturn minor;\n"
						  "\t}\n"
						  "\n"
						  "\tvoid CalculateCofactors(Matrix<T, R, C>& out) const\n"
						  "\t{\n"
						  "\t\tCalculateMinor(out);\n"
						  "\n"
						  "\t\tfor (unsigned long i = 0, s = 1; i < R; ++i, ++s)\n"
						  "\t\t{\n"
						  "\t\t\tfor (unsigned long j = s % 2; j < C; j += 2)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tout.Get(i, j) = -out.Get(i, j);\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C> CalculateTranspose() const\n"
						  "\t{\n"
						  "\t\tstatic_assert(R == C);\n"
						  "\t\tMatrix<T, C, R> out;\n"
						  "\n"
						  "\t\tfor (unsigned long i = 0; i < R; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tfor (unsigned long j = i; j < C; ++j)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tout.Get(i, j) = Get(j, i);\n"
						  "\t\t\t\tout.Get(j, i) = Get(i, j);\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\n"
						  "\t\treturn out;\n"
						  "\t}\n"
						  "\n"
						  "\tvoid CalculateTranspose(Matrix<T, R, C>& out) const\n"
						  "\t{\n"
						  "\t\tstatic_assert(R == C);\n"
						  "\n"
						  "\t\tfor (unsigned long i = 0; i < R; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tfor (unsigned long j = i; j < C; ++j)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tout.Get(i, j) = Get(j, i);\n"
						  "\t\t\t\tout.Get(j, i) = Get(i, j);\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\t}\n"
						  "\n"
						  "\tvoid CalculateRemovedRowColumn(unsigned long row, unsigned long column, Matrix<T, R - 1, C - 1>& out) const\n"
						  "\t{\n"
						  "\t\tfor (unsigned long i = 0, io = 0; i < R; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tif (i == row) continue;\n"
						  "\t\t\tfor (unsigned long j = 0, jo = 0; j < C; ++j)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tif (j == column) continue;\n"
						  "\n"
						  "\t\t\t\tout.Get(io, jo) = Get(i, j);\n"
						  "\n"
						  "\t\t\t\tjo++;\n"
						  "\t\t\t}\n"
						  "\t\t\tio++;\n"
						  "\t\t}\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R - 1, C - 1> CalculateRemovedRowColumn(unsigned long row, unsigned long column) const\n"
						  "\t{\n"
						  "\t\tMatrix<T, R - 1, C - 1> out;\n"
						  "\t\tCalculateRemovedRowColumn(row, column, out);\n"
						  "\t\treturn out;\n"
						  "\t}\n"
						  "\n"
						  "\tT CalculateDeterminant() const\n"
						  "\t{\n"
						  "\t\tstatic_assert(R == C);\n"
						  "\n"
						  "\t\tif constexpr (R > 2)\n"
						  "\t\t{\n"
						  "\t\t\tMatrix<T, R - 1, C - 1> tmp;\n"
						  "\t\t\tT det = 0.0;\n"
						  "\t\t\tT sign = 1.0;\n"
						  "\t\t\tfor (unsigned long i = 0; i < C; ++i)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tCalculateRemovedRowColumn(0, i, tmp);\n"
						  "\n"
						  "\t\t\t\tdet += sign * Get(0, i) * tmp.CalculateDeterminant();\n"
						  "\n"
						  "\t\t\t\tsign = -sign;\n"
						  "\t\t\t}\n"
						  "\n"
						  "\t\t\treturn det;\n"
						  "\t\t}\n"
						  "\t\telse\n"
						  "\t\t{\n"
						  "\t\t\treturn (_values[0] * _values[3]) - (_values[1] * _values[2]);\n"
						  "\t\t}\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C> operator-(T value) const\n"
						  "\t{\n"
						  "\t\tauto copy = *this;\n"
						  "\t\tfor (unsigned long i = 0; i < R * C; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tcopy._values[i] -= value;\n"
						  "\t\t}\n"
						  "\t\treturn copy;\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C>& operator-=(T value) const\n"
						  "\t{\n"
						  "\t\tfor (unsigned long i = 0; i < R * C; ++i)\n"
						  "\t\t{\n"
						  "\t\t\t_values[i] -= value;\n"
						  "\t\t}\n"
						  "\t\treturn *this;\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C> operator+(T value) const\n"
						  "\t{\n"
						  "\t\tauto copy = *this;\n"
						  "\t\tfor (unsigned long i = 0; i < R * C; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tcopy._values[i] += value;\n"
						  "\t\t}\n"
						  "\t\treturn copy;\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C>& operator+=(T value) const\n"
						  "\t{\n"
						  "\t\tfor (unsigned long i = 0; i < R * C; ++i)\n"
						  "\t\t{\n"
						  "\t\t\t_values[i] += value;\n"
						  "\t\t}\n"
						  "\t\treturn *this;\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C>& operator*=(T value)\n"
						  "\t{\n"
						  "\t\tfor (unsigned long i = 0; i < R * C; ++i)\n"
						  "\t\t{\n"
						  "\t\t\t_values[i] *= value;\n"
						  "\t\t}\n"
						  "\t\treturn *this;\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix<T, R, C> operator*(T value) const\n"
						  "\t{\n"
						  "\t\tauto copy = *this;\n"
						  "\t\tfor (unsigned long i = 0; i < R * C; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tcopy._values[i] *= value;\n"
						  "\t\t}\n"
						  "\t\treturn copy;\n"
						  "\t}\n"
						  "\n"
						  "\ttemplate<unsigned long Oc>\n"
						  "\tMatrix<T, R, Oc> operator*(const Matrix<T, C, Oc>& other) const\n"
						  "\t{\n"
						  "\t\tMatrix<T, R, Oc> returnMatrix;\n"
						  "\t\tfor (unsigned long i = 0; i < R; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tfor (unsigned long j = 0; j < Oc; ++j)\n"
						  "\t\t\t{\n"
						  "\t\t\t\tT product = 0.0;\n"
						  "\t\t\t\tfor (unsigned long k = 0; k < C; ++k)\n"
						  "\t\t\t\t{\n"
						  "\t\t\t\t\tproduct += Get(i, k) * other.Get(k, j);\n"
						  "\t\t\t\t}\n"
						  "\t\t\t\treturnMatrix.Get(i, j) = product;\n"
						  "\t\t\t}\n"
						  "\t\t}\n"
						  "\n"
						  "\t\treturn returnMatrix;\n"
						  "\t}\n"
						  "\n"
						  "\t[[nodiscard]]\n"
						  "\tdouble Get(unsigned long r, unsigned long c) const\n"
						  "\t{\n"
						  "\t\treturn _values[r * C + c];\n"
						  "\t}\n"
						  "\n"
						  "\tdouble& Get(unsigned long r, unsigned long c)\n"
						  "\t{\n"
						  "\t\treturn _values[r * C + c];\n"
						  "\t}\n"
						  "\n"
						  "\tconstexpr Matrix()\n"
						  "\t\t\t:_values{ 0.0 }\n"
						  "\t{\n"
						  "\n"
						  "\t}\n"
						  "\n"
						  "\tstatic constexpr Matrix<T, R, C> Identity()\n"
						  "\t{\n"
						  "\t\tMatrix<T, R, C> ret;\n"
						  "\n"
						  "\t\tfor (unsigned long i = 0; i < R * C; i += C + 1)\n"
						  "\t\t{\n"
						  "\t\t\tret._values[i] = 1.0;\n"
						  "\t\t}\n"
						  "\n"
						  "\t\treturn ret;\n"
						  "\t}\n"
						  "\n"
						  "\ttemplate<class ... TValue>\n"
						  "\tstatic constexpr Matrix<T, R, C> WithOnes(const TValue... values)\n"
						  "\t{\n"
						  "\t\tMatrix<T, R, C> ret{ values... };\n"
						  "\n"
						  "\t\tauto argumentCount = sizeof...(values);\n"
						  "\t\tif (argumentCount >= R * C)\n"
						  "\t\t{\n"
						  "\t\t\treturn ret;\n"
						  "\t\t}\n"
						  "\t\tfor (unsigned long i = argumentCount; i < (R * C) - argumentCount; ++i)\n"
						  "\t\t{\n"
						  "\t\t\tret._values[i] = 1.0;\n"
						  "\t\t}\n"
						  "\n"
						  "\t\treturn ret;\n"
						  "\t}\n"
						  "\n"
						  "\ttemplate<class ... TValue>\n"
						  "\tconstexpr explicit Matrix(const TValue... values)\n"
						  "\t\t\t:_values{ values... }\n"
						  "\t{\n"
						  "\t}\n"
						  "\n"
						  "\tMatrix(const Matrix<T, R, C>&) = default;\n"
						  "\tMatrix& operator=(const Matrix<T, R, C>&) = default;\n"
						  "\tMatrix(Matrix<T, R, C>&&) noexcept = default;\n"
						  "\tMatrix& operator=(Matrix<T, R, C>&&) noexcept = default;\n"
						  "\t~Matrix() = default;\n"
						  "private:\n"
						  "\tT _values[R * C];\n"
						  "\n"
						  "\tfriend class Matrix<T, C, R>;\n"
						  "};\n"
						  "\n"
						  "extern \"C\" double Multiply(double value, long unsigned int n)\n"
						  "{\n"
						  "\tMatrix<double, 8, 8> x = Matrix<double, 8, 8>::WithOnes();\n"
						  "\tMatrix<double, 8, 8> y = Matrix<double, 8, 8>::WithOnes();\n"
						  "\n"
						  "\tdouble accumulator = 0.0;\n"
						  "\tfor (long unsigned int i = 0; i < n; ++i)\n"
						  "\t{\n"
						  "\t\tx *= value + accumulator;\n"
						  "\t\ty *= 1.0 / (value - accumulator);\n"
						  "\t\tauto a = (x - value) * (y + value);\n"
						  "\t\tauto b = a.CalculateInverse();\n"
						  "\t\taccumulator += b.CalculateDeterminant();\n"
						  "\t}\n"
						  "\treturn accumulator;\n"
						  "}";

	void GenerateCppCodeTask::Prepare(SharedPtr<AbstractTaskData> inputData)
	{
		_outputData = std::move(inputData);
		_outputData->Allocate(sizeof(Source));
	}

	SharedPtr<AbstractTaskData> GenerateCppCodeTask::Finalize()
	{
		return std::move(_outputData);
	}

	Size GenerateCppCodeTask::GetProcessedDataSize() const
	{
		return _outputData->GetSize();
	}

	TaskInfo GenerateCppCodeTask::DoGetInfo() const
	{
		return {
				"C++ source generation",
				"Generates C++ source code",
				"Chars",
				"The byte generation throughput",
				ResultType::Throughput
		};
	}

	void GenerateCppCodeTask::DoRun()
	{
		std::memcpy(_outputData->GetData(), Source, sizeof(Source));
	}

	UniquePtr<Task> GenerateCppCodeTask::DoDuplicate() const
	{
		return std::make_unique<GenerateCppCodeTask>();
	}
} // Elpida